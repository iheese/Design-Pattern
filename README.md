# Design-Pattern

## 생성 패턴

### Factory Method
- 객체를 생성하는 클래스를 따로 두는 것을 의미한다.

#### 예제 설명
1. Item 인터페이스 정의
2. Item 인터페이스 구현체인 BananaItem, BoasterItem 정의
3. Item 구현체를 생성하는 팩토리 메소드 생성, makeItem(String) 로 구현 객체를 생성한다. 각 객체에 맞는 String 값이 들어가면 객체가 생성된다.  
4. 각 구현체를 생성하여 메소드 실행

<br>

### Abstract Factory 
- 연관성이 있는 객체 군이 여러 개 있을 경우 이를 묶어 추상화하고, 어떤 구체적인 상황이 주어지면 팩토리 객체에서 묶은 객체 군을 구현화하는 생성 패턴입니다.
- 클라이언트에서 객체를 사용할 때 팩토리 클래스마을 참조하여 특정 객체에 대한 구현부를 감추어 역할과 구현을 분리할 수 있습니다.
> - 결합도를 낮출 수 있다. 
- 팩토리 변경만 하면 되니 제품군의 변경이 쉬워진다. 

#### 예제 설명
1. 옷, 바지 인터페이스를 생성하고, 옷과 바지를 생성하는 팩토리 인터페이스를 생성한다.
2. 옷, 바지의 소재별로 구현체를 구현하고, 소재별 팩토리를 구현하고 팩토리에서 소재에 맞게 알아서 해당 객체를 생성한다.
3. 클라이언트(AbstractFactoryMain) 에서는 팩토리 생성만 다르게 하면 다른 객체를 생성해준다.

#### 단점
- 각 구현체마다 팩토리 객체들을 모두 구현해주어야 하기 때문에 클래스가 증가하여 복잡성이 증가한다.
- 기존 추상 팩토리 세부사항이 변결될 경우 모든 팩토리에 대한 수정이 필요해진다.
- 새로운 종류 제품 지원이 어렵다. 새로운 제품이 추가되면 팩토리 구현 로직 자체를 변경해야 한다. 

<br>

### Singleton
- 인스턴스를 하나만 만들어 사용하기 위한 패턴입니다.

#### 예제 설명
1. Government 객체는 하나의 인스턴스만을 생성하여 리턴합니다.
2. Main 함수에서 실행되었을 때 모두 같은 객체를 참조하고 하나의 객체가 메소드를 실행시키는 것을 알 수 있습니다.

- 싱글턴 패턴은 동시성 문제를 일으킬 수 있다.
> - [싱글턴 패턴 동시성 해결 예제](https://cjw-awdsd.tistory.com/42)

<br>

### Builder
- 복잡한 객체들을 단계별로 생성할 수 있도록 하는 생성 패턴입니다. 
- 많은 선택적인 멤버 변수나 지속성이 없는 상태값들(동적인)에 대해 처리해야하는 문제들을 해결합니다.
- 생성자 없이 변경 가능성을 최소화하며 불변셩을 가지게 해준다. 

#### 예제 설명
1. Person 객체 내 필수 인자, 선택 인자를 구분하여 생성합니다.
2. Builder 이너 클래스를 생성하고 Person 과 같은 인자들을 생성합니다. Person 객체는 Builder 를 주입받는 생성자를 생성해줍니다.
3. Builder 이너 클래스는 필수 인자는 생성자에서 입력받게 하고, 선택 인자는 인자값를 입력받고 해당 빌더 객체를 리턴하는 메소드를 통해 입력받습니다.
4. Builder 이너 클래스에 Person 객체 생성을 마무리하고 리턴하는 build() 메소드를 생성하고 마무리합니다. 

#### 단점
- 코드 복잡성이 증가한다.
> - 빌더 패턴을 적용하기 위해선 모두 이너 클래스를 생성하든, 빌더 클래스를 따로 생성해야 해서 코드양이 늘어나고 구조가 복잡해질 수 있다. 다만 여느 다지안 패턴이 가지는 단점이다.
- 생성자 보다는 성능은 떨어진다.
> - 메소드 호출 후 빌더를 거쳐 인스턴스화하기 때문에 생성자 보다는 당연히 성능이 떨어질 수 있다.

<br>

## 구조 패턴

### Proxy
- 원래 객체에 대한 접근을 제어하고, 요청이 원래 객체에 전달되기 전 후에 무언가를 수행할 수 있게 한다.
- 로직 중간에 대리자를 생성하여 업무를 대신 처리하고 사용자가 어떻게 일처리하는지 모르게 할 수 있다.

#### 예제 설명
1. 클라이언트 인터페이스를 구현한 일반 클라이인트(NormalClient)는 그냥 비교하면 서로의 정보를 조회할 수 있게 된다.
2. 클라이언트 인터페이스를 구현한 프록시 객체를 생성 자신의 정보는 자신만 조회할 수 있는 로직을 추가해준다. 
3. 철수와 영희 객체를 만들고 철수 프록시를 만들고 철수 프록시를 통해 영희를 조회하면 조회할 수 없게 된다.

<br>

### Decorator
- 객체들을 새로운 행동들을 포함한 래퍼 객체를에 넣어서 위 행동들을 연결시키는 패턴  
- 런타임 시 유연하게 객체의 기능을 수정하고 조합하는데 유용하게 사용회는 패턴입니다.
- FileReader, BufferedReader 등의 IO 클래스에서 사용된다. 
- 단점: 다수의 데코레이터 패턴을 생성해야 한다.

#### 예제 설명
1. 드링크라는 인터페이스가 있고 그것을 구현한 기본 음료 클래스가 있다.
2. 드링크라는 인터페이스를 이용하는 데코레이터 객체(래퍼 객체)를 만든다. 데코레이터 객체는 생성자 인수로 받은 객체의 메소드(add())를 이용한다.
3. WhippedDrink, CaramelDrink 는 데코레이터 객체를 상속한다. 두 객체는 먼저 상속한 객체의 메소드를 호출하고 자신의 추가된 기능을 호출한다.
4. 기본 음료를 기반으로 래퍼 객체에 넣어 다양한 조합으로 연결시킬 수 있게 된다. 

<br>

### Adapter
- 호환되지 않는 인터페이스를 가진 객체들이 협업할 수 있도록 하는 구조적 디자인 패턴입니다. 

#### 예제 설명
1. 110v, 220v 플러그 인터페이스가 있습니다. 110v는 일본 플러그로 구현하고 220v는 한국 플러그로 구현하였습니다.
2. 한국 플러그를 사용하다가 일본 플러그를 사용해야 할 일이 생겼다면 110v 어댑터를 이용합니다. 
3. 클라이언트에서는 110v 어댑터에 일본 플러그 객체만 주입해주고 한국 플러그를 사용한 것처럼 그대로 메소드를 사용하면 됩니다. 

<br>

### Facade
- 거대한 코드 집합에 대한 단순화된 인터페이스를 제공하는 디자인 패턴입니다.
- GoF : 서브 시스템을 더 쉽게 사용할 수 있도록 high-level 인터페이스를 정의하고 제공합니다.

#### 예제 설명
1. sub 패키지에는 옷에 대한 클래스, 가방에 대한 클래스, 문에 대한 클래스가 개별적으로 존재한다.
2. Facade 클래스는 서브 클래스들의 메소드를 조합하여 메소드를 만들어 제공한다.
3. FacadeMain 에서는 서브 클래스에 대해 몰라도 Facade 클래스만 사용하면 복잡한 기능들을 사용할 수 있다. 

<br>

## 행위 패턴

### Strategy
- 상황에 따라 다른 전략을 사용하기 위한 패턴
- 선택한 알고리즘이 전략이 되고, 전략을 선택하는 주체인 컨텍스트(Context)가 필요하다. 컨텍스트에 전략을 주입해주는 클라이언트(client) 가 필요한다.
- DI (Dependency Injection) 개념이 사용된다.

#### 예제 설명
1. 스트레스 푸는 전략 인터페이스가 존재한다. 그에 대한 전략 구현체 Eat, Play, Sleep 을 생성한다.
2. 클라이언트는 StrategyMain 이 되고, Person 은 전략 타입을 주입 받아 수행하는 역할아다.
3. 각 구체 클래스를 Person 객체 메소드에 주입하여 전략을 달리 가져갈 수 있다. 

<br>

### Template Method
- 여러 객체들은 추상 클래스, 인터페이스에서 동일한 이름의 메소드를 구현하되, 기타 메소드는 각 객체에 맞게 구현
- 템플릿 메소드, 추상 메소드, 훅 메소드로 나뉩니다.
> - 템플릿 메소드 : 공통된 역할
> - 추상 메소드 : 반드시 구현해야 하는 메소드
> - 훅 메소드 : 그대로 사용해도 되고, 오버라이딩 해서 사용해도 되는 메소드
- 하위 클래스가 전체 로직을 변경하지 않으면서 부분적인 수정이 가능하고, 전체적인 알고리즘 구조를 보호합니다.

#### 예제 설명
1. Coffee 상위 추상 클래스 생성(템플릿 메소드(다른 메소드를 순서대로 한번에 호출), 추상 메소드, 훅메소드 생성), 상위 클래스에서 공통으로 사용되는 메소드 구현했다.
2. 상위 클래스의 추상 메소드는 무조건 오버라이딩하고, 훅 메소드는 해도 되고 안해도 된다.
3. 각 구체 클래스에서 템플릿 메소드를 실행한다. 

#### vs Factory Method 
- 팩토리 메소드는 템플릿 메소드의 특수화이다. 동시에 대규모 템플릿 메소드의 한 단계 역항을 팩토리 메소드가 할 수 있다. 
- 템플릿 메소드는 하위 클래스에서 구체적인 행동을 만들도록 해서 추상 메소드를 상속하게 했고, 팩토리 메소드는 인스턴스 생성에 적용한 것이다. 

<br>

### Observer
- 자신이 관찰 중인 객체에 발생하는 모든 이벤트를 여러 객체에게 알리는 구독 메커니즘을 정의할 수 있도록 하는 행동 패턴이다.
- 일대다 의존성을 가지며, 분산 이벤트 핸들링 시스템 구현에 사용, Pub-Sub 모델로 알려져 있다.
- 발행자(상태를 변경하는 객체)와 관찰자(변경을 감지하는 객체) 사이의 느슨한 결합
- 발행자 코드의 변경 없이도 관찰자를 추가할 수 있다는 점에서 OCP(개발 폐쇠 원칙)을 준수한다. 

#### 예제 설명
1. 관찰자 인터페이스(Observer) 는 알람을 받는 메소드를 가진다. 발행자 인터페이스(Publisher)는 관찰자 추가, 삭제, 관찰자들에게 알람을 전달하는 메소드를 가진다.
2. Subscriber 1,2,3 은 관찰자들이고, YoutubeChannel은 발행자이다.
3. 유투브 채널 객체와 구독자 객체 3개를 생성하고 구독하게 한다.
4. 알람을 전달하면 유투브 채널을 구독하고 있는 구독자들에게 알람이 전달된다.

#### 단점
- 알람 순서를 보장할 수 없다.
- 다수의 관찰자 객체 등록 후 해지하지 않으면 메모리 누수 발생 가능성

<br>

#### Reference
- [Refactoring GURU](https://refactoring.guru/ko)
- [Inpa Dev](https://inpa.tistory.com/)