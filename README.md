# Design-Pattern

## 생성 패턴

### Factory Method
- 객체를 생성하는 클래스를 따로 두는 것을 의미한다.

#### 예제 설명
1. Item 인터페이스 정의
2. Item 인터페이스 구현체인 BananaItem, BoasterItem 정의
3. Item 구현체를 생성하는 팩토리 메소드 생성, makeItem(String) 로 구현 객체를 생성한다. 각 객체에 맞는 String 값이 들어가면 객체가 생성된다.  
4. 각 구현체를 생성하여 메소드 실행

<br>

### Singleton
- 인스턴스를 하나만 만들어 사용하기 위한 패턴입니다.

#### 예제 설명
1. Government 객체는 하나의 인스턴스만을 생성하여 리턴합니다.
2. Main 함수에서 실행되었을 때 모두 같은 객체를 참조하고 하나의 객체가 메소드를 실행시키는 것을 알 수 있습니다.

- 싱글턴 패턴은 동시성 문제를 일으킬 수 있다. 
> - [싱글턴 패턴 동시성 해결 예제](https://cjw-awdsd.tistory.com/42)

<br>

### Abstract Factory 
- 연관성이 있는 객체 군이 여러 개 있을 경우 이를 묶어 추상화하고, 어떤 구체적인 상황이 주어지면 팩토리 객체에서 묶은 객체 군을 구현화하는 생성 패턴입니다.
- 클라이언트에서 객체를 사용할 때 팩토리 클래스마을 참조하여 특정 객체에 대한 구현부를 감추어 역할과 구현을 분리할 수 있습니다.
> - 결합도를 낮출 수 있다. 
- 팩토리 변경만 하면 되니 제품군의 변경이 쉬워진다. 

#### 예제 설명
1. 옷, 바지 인터페이스를 생성하고, 옷과 바지를 생성하는 팩토리 인터페이스를 생성한다.
2. 옷, 바지의 소재별로 구현체를 구현하고, 소재별 팩토리를 구현하고 팩토리에서 소재에 맞게 알아서 해당 객체를 생성한다.
3. 클라이언트(AbstractFactoryMain) 에서는 팩토리 생성만 다르게 하면 다른 객체를 생성해준다.

#### 단점
- 각 구현체마다 팩토리 객체들을 모두 구현해주어야 하기 때문에 클래스가 증가하여 복잡성이 증가한다.
- 기존 추상 팩토리 세부사항이 변결될 경우 모든 팩토리에 대한 수정이 필요해진다.
- 새로운 종류 제품 지원이 어렵다. 새로운 제품이 추가되면 팩토리 구현 로직 자체를 변경해야 한다. 

<br>

## 구조 패턴

### Proxy
- 원래 객체에 대한 접근을 제어하고, 요청이 원래 객체에 전달되기 전 후에 무언가를 수행할 수 있게 한다.
- 로직 중간에 대리자를 생성하여 업무를 대신 처리하고 사용자가 어떻게 일처리하는지 모르게 할 수 있다.

#### 예제 설명
1. 클라이언트 인터페이스를 구현한 일반 클라이인트(NormalClient)는 그냥 비교하면 서로의 정보를 조회할 수 있게 된다.
2. 클라이언트 인터페이스를 구현한 프록시 객체를 생성 자신의 정보는 자신만 조회할 수 있는 로직을 추가해준다. 
3. 철수와 영희 객체를 만들고 철수 프록시를 만들고 철수 프록시를 통해 영희를 조회하면 조회할 수 없게 된다.

<br>

### Decorator
- 객체들을 새로운 행동들을 포함한 래퍼 객체를에 넣어서 위 행동들을 연결시키는 패턴  
- 런타임 시 유연하게 객체의 기능을 수정하고 조합하는데 유용하게 사용회는 패턴입니다.
- FileReader, BufferedReader 등의 IO 클래스에서 사용된다. 
- 단점: 다수의 데코레이터 패턴을 생성해야 한다.

#### 예제 설명
1. 드링크라는 인터페이스가 있고 그것을 구현한 기본 음료 클래스가 있다.
2. 드링크라는 인터페이스를 이용하는 데코레이터 객체(래퍼 객체)를 만든다. 데코레이터 객체는 생성자 인수로 받은 객체의 메소드(add())를 이용한다.
3. WhippedDrink, CaramelDrink 는 데코레이터 객체를 상속한다. 두 객체는 먼저 상속한 객체의 메소드를 호출하고 자신의 추가된 기능을 호출한다.
4. 기본 음료를 기반으로 래퍼 객체에 넣어 다양한 조합으로 연결시킬 수 있게 된다. 


<br>

## 행위 패턴

### Strategy
- 상황에 따라 다른 전략을 사용하기 위한 패턴
- 선택한 알고리즘이 전략이 되고, 전략을 선택하는 주체인 컨텍스트(Context)가 필요하다. 컨텍스트에 전략을 주입해주는 클라이언트(client) 가 필요한다.
- DI (Dependency Injection) 개념이 사용된다.

#### 예제 설명
1. 스트레스 푸는 전략 인터페이스가 존재한다. 그에 대한 전략 구현체 Eat, Play, Sleep 을 생성한다.
2. 클라이언트는 StrategyMain 이 되고, Person 은 전략 타입을 주입 받아 수행하는 역할아다.
3. 각 구체 클래스를 Person 객체 메소드에 주입하여 전략을 달리 가져갈 수 있다. 

<br>

### Template Method
- 여러 객체들은 추상 클래스, 인터페이스에서 동일한 이름의 메소드를 구현하되, 기타 메소드는 각 객체에 맞게 구현
- 템플릿 메소드, 추상 메소드, 훅 메소드로 나뉩니다.
> - 템플릿 메소드 : 공통된 역할
> - 추상 메소드 : 반드시 구현해야 하는 메소드
> - 훅 메소드 : 그대로 사용해도 되고, 오버라이딩 해서 사용해도 되는 메소드
- 하위 클래스가 전체 로직을 변경하지 않으면서 부분적인 수정이 가능하고, 전체적인 알고리즘 구조를 보호합니다.

#### 예제 설명
1. Coffee 상위 추상 클래스 생성(템플릿 메소드(다른 메소드를 순서대로 한번에 호출), 추상 메소드, 훅메소드 생성), 상위 클래스에서 공통으로 사용되는 메소드 구현했다.
2. 상위 클래스의 추상 메소드는 무조건 오버라이딩하고, 훅 메소드는 해도 되고 안해도 된다.
3. 각 구체 클래스에서 템플릿 메소드를 실행한다. 